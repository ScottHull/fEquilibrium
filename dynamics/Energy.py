from math import pi, sqrt
import pandas as pd



class thermal_eq:

    def __init__(self):
        pass

    @classmethod
    def nearest_neighboor(self, system_data, x_coord, y_coord, z_coord):
        neighbors = []
        minimum = 0
        for row in system_data.index:
            if system_data['x_coords'][row] == x_coord and system_data['y_coords'][row] == y_coord and system_data['z_coords'][row] == z_coord:
                pass
            else:
                sample_xcoord = system_data['x_coords'][row]
                sample_ycoord = system_data['y_coords'][row]
                sample_zcoord = system_data['z_coords'][row]
                distance = sqrt(((sample_xcoord - x_coord)**2) + ((sample_ycoord - y_coord)**2) + ((sample_zcoord - z_coord)**2))
                if minimum == 0:
                    minimum = distance
                elif distance < minimum:
                    minimum = distance

        for row in system_data.index:
            if system_data['x_coords'][row] == x_coord and system_data['y_coords'][row] == y_coord and \
                            system_data['z_coords'][row] == z_coord:
                pass
            else:
                sample_xcoord = system_data['x_coords'][row]
                sample_ycoord = system_data['y_coords'][row]
                sample_zcoord = system_data['z_coords'][row]
                distance = sqrt(((sample_xcoord - x_coord) ** 2) + ((sample_ycoord - y_coord) ** 2) + (
                (sample_zcoord - z_coord) ** 2))
                if distance == minimum:
                    sample_neighbors = []
                    sample_neighbors.append(sample_xcoord)
                    sample_neighbors.append(sample_ycoord)
                    sample_neighbors.append(sample_zcoord)
                    neighbors.append(sample_neighbors)
        return neighbors


    def D3_thermal_eq(self, system_data):
        for row in system_data.index:
            sample_xcoord = system_data['x_coords'][row]
            sample_ycoord = system_data['y_coords'][row]
            sample_zcoord = system_data['z_coords'][row]
            neighbors = self.nearest_neighboor(system_data=system_data, x_coord=sample_xcoord, y_coord=sample_ycoord,
                                               z_coord=sample_zcoord)
            print("x:{} y:{}, z:{} neighbors: {}".format(sample_xcoord, sample_ycoord, sample_zcoord, len(neighbors)))



class energy:

    def __init__(self):
        self.gravity = 9.81

    def stokes_frictional_energy(self, body_material, matrix_material, body_radius, body_mass, distance_travelled):
        """
        The Stokes settling velocity calculates a terminal velocity, so there is no acceleration.  The frictional force
        (drag force) must therefore balance the force due to gravity, Fg=Fd.
        :return:
        """
        df = pd.read_csv('physical_parameters.csv', index_col='Material')
        body_cp = df['C_p'][body_material] # specific heat of the body
        body_density = df['Density'][body_material]
        matrix_density = df['Density'][matrix_material]
        F_d = (body_density - matrix_density) * self.gravity * (4/3) * pi * (body_radius**3) # the force generated by
        # frictional drag.  Must be converted to energy and added to the body temperature.
        # W = F * d, Units = [J]
        W = F_d * distance_travelled
        # convert joules to degK, Q[J]=M[g] * Cp * T[degK] --> T=Q/(M*Cp)
        degK = W / (body_cp * body_mass) # the temperature to be added to the body
        return degK




    # def distribute_stokes_frictional_energy(self, frictional_energy, path_coords):
    #     """
    #     Frictional energy shall be distributed along the path of movement evenly.
    #     :param frictional_energy:
    #     :param path_coords:
    #     :return: energy_unit, energy per grid unit
    #     """
    #     path_length = len(path_coords)
    #     energy_unit = frictional_energy / path_length
    #     return energy_unit

    def kinetic_energy(self, mass, velocity):
        ke = 0.5 * mass * (velocity**2) # ke = 1/2*m*v^2
        return ke
    #
    def potential_energy(self, mass, height):
        pe = mass * self.gravity * height # pe = m*g*h
        return pe
    #
    # def release_energy(self, former_pe, current_pe):
    #     friction_energy = abs(current_pe - former_pe) # assume that all energy release as frictional energy, or the
    #     #       difference in the potential energies at position 2 and position 1
    #     return friction_energy